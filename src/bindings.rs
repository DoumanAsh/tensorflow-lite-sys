/* automatically generated by rust-bindgen 0.65.1 */

pub type va_list = __builtin_va_list;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TfLiteBuiltinOperator {
    kTfLiteBuiltinAdd = 0,
    kTfLiteBuiltinAveragePool2d = 1,
    kTfLiteBuiltinConcatenation = 2,
    kTfLiteBuiltinConv2d = 3,
    kTfLiteBuiltinDepthwiseConv2d = 4,
    kTfLiteBuiltinDepthToSpace = 5,
    kTfLiteBuiltinDequantize = 6,
    kTfLiteBuiltinEmbeddingLookup = 7,
    kTfLiteBuiltinFloor = 8,
    kTfLiteBuiltinFullyConnected = 9,
    kTfLiteBuiltinHashtableLookup = 10,
    kTfLiteBuiltinL2Normalization = 11,
    kTfLiteBuiltinL2Pool2d = 12,
    kTfLiteBuiltinLocalResponseNormalization = 13,
    kTfLiteBuiltinLogistic = 14,
    kTfLiteBuiltinLshProjection = 15,
    kTfLiteBuiltinLstm = 16,
    kTfLiteBuiltinMaxPool2d = 17,
    kTfLiteBuiltinMul = 18,
    kTfLiteBuiltinRelu = 19,
    kTfLiteBuiltinReluN1To1 = 20,
    kTfLiteBuiltinRelu6 = 21,
    kTfLiteBuiltinReshape = 22,
    kTfLiteBuiltinResizeBilinear = 23,
    kTfLiteBuiltinRnn = 24,
    kTfLiteBuiltinSoftmax = 25,
    kTfLiteBuiltinSpaceToDepth = 26,
    kTfLiteBuiltinSvdf = 27,
    kTfLiteBuiltinTanh = 28,
    kTfLiteBuiltinConcatEmbeddings = 29,
    kTfLiteBuiltinSkipGram = 30,
    kTfLiteBuiltinCall = 31,
    kTfLiteBuiltinCustom = 32,
    kTfLiteBuiltinEmbeddingLookupSparse = 33,
    kTfLiteBuiltinPad = 34,
    kTfLiteBuiltinUnidirectionalSequenceRnn = 35,
    kTfLiteBuiltinGather = 36,
    kTfLiteBuiltinBatchToSpaceNd = 37,
    kTfLiteBuiltinSpaceToBatchNd = 38,
    kTfLiteBuiltinTranspose = 39,
    kTfLiteBuiltinMean = 40,
    kTfLiteBuiltinSub = 41,
    kTfLiteBuiltinDiv = 42,
    kTfLiteBuiltinSqueeze = 43,
    kTfLiteBuiltinUnidirectionalSequenceLstm = 44,
    kTfLiteBuiltinStridedSlice = 45,
    kTfLiteBuiltinBidirectionalSequenceRnn = 46,
    kTfLiteBuiltinExp = 47,
    kTfLiteBuiltinTopkV2 = 48,
    kTfLiteBuiltinSplit = 49,
    kTfLiteBuiltinLogSoftmax = 50,
    kTfLiteBuiltinDelegate = 51,
    kTfLiteBuiltinBidirectionalSequenceLstm = 52,
    kTfLiteBuiltinCast = 53,
    kTfLiteBuiltinPrelu = 54,
    kTfLiteBuiltinMaximum = 55,
    kTfLiteBuiltinArgMax = 56,
    kTfLiteBuiltinMinimum = 57,
    kTfLiteBuiltinLess = 58,
    kTfLiteBuiltinNeg = 59,
    kTfLiteBuiltinPadv2 = 60,
    kTfLiteBuiltinGreater = 61,
    kTfLiteBuiltinGreaterEqual = 62,
    kTfLiteBuiltinLessEqual = 63,
    kTfLiteBuiltinSelect = 64,
    kTfLiteBuiltinSlice = 65,
    kTfLiteBuiltinSin = 66,
    kTfLiteBuiltinTransposeConv = 67,
    kTfLiteBuiltinSparseToDense = 68,
    kTfLiteBuiltinTile = 69,
    kTfLiteBuiltinExpandDims = 70,
    kTfLiteBuiltinEqual = 71,
    kTfLiteBuiltinNotEqual = 72,
    kTfLiteBuiltinLog = 73,
    kTfLiteBuiltinSum = 74,
    kTfLiteBuiltinSqrt = 75,
    kTfLiteBuiltinRsqrt = 76,
    kTfLiteBuiltinShape = 77,
    kTfLiteBuiltinPow = 78,
    kTfLiteBuiltinArgMin = 79,
    kTfLiteBuiltinFakeQuant = 80,
    kTfLiteBuiltinReduceProd = 81,
    kTfLiteBuiltinReduceMax = 82,
    kTfLiteBuiltinPack = 83,
    kTfLiteBuiltinLogicalOr = 84,
    kTfLiteBuiltinOneHot = 85,
    kTfLiteBuiltinLogicalAnd = 86,
    kTfLiteBuiltinLogicalNot = 87,
    kTfLiteBuiltinUnpack = 88,
    kTfLiteBuiltinReduceMin = 89,
    kTfLiteBuiltinFloorDiv = 90,
    kTfLiteBuiltinReduceAny = 91,
    kTfLiteBuiltinSquare = 92,
    kTfLiteBuiltinZerosLike = 93,
    kTfLiteBuiltinFill = 94,
    kTfLiteBuiltinFloorMod = 95,
    kTfLiteBuiltinRange = 96,
    kTfLiteBuiltinResizeNearestNeighbor = 97,
    kTfLiteBuiltinLeakyRelu = 98,
    kTfLiteBuiltinSquaredDifference = 99,
    kTfLiteBuiltinMirrorPad = 100,
    kTfLiteBuiltinAbs = 101,
    kTfLiteBuiltinSplitV = 102,
    kTfLiteBuiltinUnique = 103,
    kTfLiteBuiltinCeil = 104,
    kTfLiteBuiltinReverseV2 = 105,
    kTfLiteBuiltinAddN = 106,
    kTfLiteBuiltinGatherNd = 107,
    kTfLiteBuiltinCos = 108,
    kTfLiteBuiltinWhere = 109,
    kTfLiteBuiltinRank = 110,
    kTfLiteBuiltinElu = 111,
    kTfLiteBuiltinReverseSequence = 112,
    kTfLiteBuiltinMatrixDiag = 113,
    kTfLiteBuiltinQuantize = 114,
    kTfLiteBuiltinMatrixSetDiag = 115,
    kTfLiteBuiltinRound = 116,
    kTfLiteBuiltinHardSwish = 117,
    kTfLiteBuiltinIf = 118,
    kTfLiteBuiltinWhile = 119,
    kTfLiteBuiltinNonMaxSuppressionV4 = 120,
    kTfLiteBuiltinNonMaxSuppressionV5 = 121,
    kTfLiteBuiltinScatterNd = 122,
    kTfLiteBuiltinSelectV2 = 123,
    kTfLiteBuiltinDensify = 124,
    kTfLiteBuiltinSegmentSum = 125,
    kTfLiteBuiltinBatchMatmul = 126,
    kTfLiteBuiltinPlaceholderForGreaterOpCodes = 127,
    kTfLiteBuiltinCumsum = 128,
    kTfLiteBuiltinCallOnce = 129,
    kTfLiteBuiltinBroadcastTo = 130,
    kTfLiteBuiltinRfft2d = 131,
    kTfLiteBuiltinConv3d = 132,
    kTfLiteBuiltinImag = 133,
    kTfLiteBuiltinReal = 134,
    kTfLiteBuiltinComplexAbs = 135,
    kTfLiteBuiltinHashtable = 136,
    kTfLiteBuiltinHashtableFind = 137,
    kTfLiteBuiltinHashtableImport = 138,
    kTfLiteBuiltinHashtableSize = 139,
    kTfLiteBuiltinReduceAll = 140,
    kTfLiteBuiltinConv3dTranspose = 141,
    kTfLiteBuiltinVarHandle = 142,
    kTfLiteBuiltinReadVariable = 143,
    kTfLiteBuiltinAssignVariable = 144,
    kTfLiteBuiltinBroadcastArgs = 145,
    kTfLiteBuiltinRandomStandardNormal = 146,
    kTfLiteBuiltinBucketize = 147,
    kTfLiteBuiltinRandomUniform = 148,
    kTfLiteBuiltinMultinomial = 149,
    kTfLiteBuiltinGelu = 150,
    kTfLiteBuiltinDynamicUpdateSlice = 151,
    kTfLiteBuiltinRelu0To1 = 152,
    kTfLiteBuiltinUnsortedSegmentProd = 153,
    kTfLiteBuiltinUnsortedSegmentMax = 154,
    kTfLiteBuiltinUnsortedSegmentSum = 155,
    kTfLiteBuiltinAtan2 = 156,
    kTfLiteBuiltinUnsortedSegmentMin = 157,
    kTfLiteBuiltinSign = 158,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TfLiteStatus {
    kTfLiteOk = 0,
    kTfLiteError = 1,
    kTfLiteDelegateError = 2,
    kTfLiteApplicationError = 3,
    kTfLiteDelegateDataNotFound = 4,
    kTfLiteDelegateDataWriteError = 5,
    kTfLiteDelegateDataReadError = 6,
    kTfLiteUnresolvedOps = 7,
    kTfLiteCancelled = 8,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TfLiteType {
    kTfLiteNoType = 0,
    kTfLiteFloat32 = 1,
    kTfLiteInt32 = 2,
    kTfLiteUInt8 = 3,
    kTfLiteInt64 = 4,
    kTfLiteString = 5,
    kTfLiteBool = 6,
    kTfLiteInt16 = 7,
    kTfLiteComplex64 = 8,
    kTfLiteInt8 = 9,
    kTfLiteFloat16 = 10,
    kTfLiteFloat64 = 11,
    kTfLiteComplex128 = 12,
    kTfLiteUInt64 = 13,
    kTfLiteResource = 14,
    kTfLiteVariant = 15,
    kTfLiteUInt32 = 16,
    kTfLiteUInt16 = 17,
    kTfLiteInt4 = 18,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteQuantizationParams {
    pub scale: f32,
    pub zero_point: i32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteOpaqueContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteOpaqueNode {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteOpaqueTensor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteDelegate {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteOpaqueDelegateStruct {
    _unused: [u8; 0],
}
pub type TfLiteOpaqueDelegate = TfLiteDelegate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteModel {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteInterpreterOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteInterpreter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteTensor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteRegistrationExternal {
    _unused: [u8; 0],
}
pub type __builtin_va_list = *mut core::ffi::c_char;
extern "C" {
    #[doc = " The TensorFlow Lite Runtime version.\n\n Returns a pointer to a statically allocated string that is the version\n number of the (potentially dynamically loaded) TF Lite Runtime library.\n TensorFlow Lite uses semantic versioning, and the return value should be\n in semver 2 format <http://semver.org>, starting with MAJOR.MINOR.PATCH,\n e.g. \"2.12.0\" or \"2.13.0-rc2\"."]
    pub fn TfLiteVersion() -> *const core::ffi::c_char;
    #[doc = " The supported TensorFlow Lite model file Schema version.\n\n Returns the (major) version number of the Schema used for model\n files that is supported by the (potentially dynamically loaded)\n TensorFlow Lite Runtime.\n\n Model files using schema versions different to this may not be supported by\n the current version of the TF Lite Runtime."]
    pub fn TfLiteSchemaVersion() -> core::ffi::c_int;
    #[doc = " Returns a model from the provided buffer, or null on failure.\n\n \\note The caller retains ownership of the `model_data` buffer and should\n ensure that the lifetime of the `model_data` buffer must be at least as long\n as the lifetime of the `TfLiteModel` and of any `TfLiteInterpreter` objects\n created from that `TfLiteModel`, and furthermore the contents of the\n `model_data` buffer must not be modified during that time.\""]
    pub fn TfLiteModelCreate(
        model_data: *const core::ffi::c_void,
        model_size: usize,
    ) -> *mut TfLiteModel;
    #[doc = " Same as `TfLiteModelCreate` with customizble error reporter.\n * `reporter` takes the provided `user_data` object, as well as a C-style\n   format string and arg list (see also vprintf).\n * `user_data` is optional. If non-null, it is owned by the client and must\n   remain valid for the duration of the interpreter lifetime."]
    pub fn TfLiteModelCreateWithErrorReporter(
        model_data: *const core::ffi::c_void,
        model_size: usize,
        reporter: ::core::option::Option<
            unsafe extern "C" fn(
                user_data: *mut core::ffi::c_void,
                format: *const core::ffi::c_char,
                args: va_list,
            ),
        >,
        user_data: *mut core::ffi::c_void,
    ) -> *mut TfLiteModel;
    #[doc = " Returns a model from the provided file, or null on failure.\n\n \\note The file's contents must not be modified during the lifetime of the\n `TfLiteModel` or of any `TfLiteInterpreter` objects created from that\n `TfLiteModel`."]
    pub fn TfLiteModelCreateFromFile(model_path: *const core::ffi::c_char) -> *mut TfLiteModel;
    #[doc = " Same as `TfLiteModelCreateFromFile` with customizble error reporter.\n * `reporter` takes the provided `user_data` object, as well as a C-style\n   format string and arg list (see also vprintf).\n * `user_data` is optional. If non-null, it is owned by the client and must\n   remain valid for the duration of the interpreter lifetime."]
    pub fn TfLiteModelCreateFromFileWithErrorReporter(
        model_path: *const core::ffi::c_char,
        reporter: ::core::option::Option<
            unsafe extern "C" fn(
                user_data: *mut core::ffi::c_void,
                format: *const core::ffi::c_char,
                args: va_list,
            ),
        >,
        user_data: *mut core::ffi::c_void,
    ) -> *mut TfLiteModel;
    #[doc = " Destroys the model instance."]
    pub fn TfLiteModelDelete(model: *mut TfLiteModel);
    #[doc = " Returns a new interpreter options instances."]
    pub fn TfLiteInterpreterOptionsCreate() -> *mut TfLiteInterpreterOptions;
    #[doc = " Creates and returns a shallow copy of an options object.\n\n The caller is responsible for calling `TfLiteInterpreterOptionsDelete` to\n deallocate the object pointed to by the returned pointer."]
    pub fn TfLiteInterpreterOptionsCopy(
        from: *const TfLiteInterpreterOptions,
    ) -> *mut TfLiteInterpreterOptions;
    #[doc = " Destroys the interpreter options instance."]
    pub fn TfLiteInterpreterOptionsDelete(options: *mut TfLiteInterpreterOptions);
    #[doc = " Sets the number of CPU threads to use for the interpreter."]
    pub fn TfLiteInterpreterOptionsSetNumThreads(
        options: *mut TfLiteInterpreterOptions,
        num_threads: i32,
    );
    #[doc = " Adds a delegate to be applied during `TfLiteInterpreter` creation.\n\n If delegate application fails, interpreter creation will also fail with an\n associated error logged.\n\n \\note The caller retains ownership of the delegate and should ensure that it\n remains valid for the duration of any created interpreter's lifetime.\n\n If you are NOT using \"TensorFlow Lite in Play Services\", and NOT building\n with `TFLITE_WITH_STABLE_ABI` or `TFLITE_USE_OPAQUE_DELEGATE` macros\n enabled, it is possible to pass a `TfLiteDelegate*` rather than a\n `TfLiteOpaqueDelegate*` to this function, since in those cases,\n `TfLiteOpaqueDelegate` is just a typedef alias for `TfLiteDelegate`.\n This is for compatibility with existing source code\n and existing delegates.  For new delegates, it is recommended to\n use `TfLiteOpaqueDelegate` rather than `TfLiteDelegate`.  (See\n `TfLiteOpaqueDelegate` in tensorflow/lite/core/c/c_api_types.h.)"]
    pub fn TfLiteInterpreterOptionsAddDelegate(
        options: *mut TfLiteInterpreterOptions,
        delegate: *mut TfLiteOpaqueDelegate,
    );
    #[doc = " Sets a custom error reporter for interpreter execution.\n\n * `reporter` takes the provided `user_data` object, as well as a C-style\n   format string and arg list (see also vprintf).\n * `user_data` is optional. If non-null, it is owned by the client and must\n   remain valid for the duration of the interpreter lifetime."]
    pub fn TfLiteInterpreterOptionsSetErrorReporter(
        options: *mut TfLiteInterpreterOptions,
        reporter: ::core::option::Option<
            unsafe extern "C" fn(
                user_data: *mut core::ffi::c_void,
                format: *const core::ffi::c_char,
                args: va_list,
            ),
        >,
        user_data: *mut core::ffi::c_void,
    );
    #[doc = " Adds an op registration to be applied during `TfLiteInterpreter` creation.\n\n The `TfLiteRegistrationExternal` object is needed to implement custom op of\n TFLite Interpreter via C API. Calling this function ensures that any\n `TfLiteInterpreter` created with the specified `options` can execute models\n that use the custom operator specified in `registration`.\n Please refer https://www.tensorflow.org/lite/guide/ops_custom for custom op\n support.\n \\note The caller retains ownership of the TfLiteRegistrationExternal object\n and should ensure that it remains valid for the duration of any created\n interpreter's lifetime.\n \\warning This is an experimental API and subject to change."]
    pub fn TfLiteInterpreterOptionsAddRegistrationExternal(
        options: *mut TfLiteInterpreterOptions,
        registration: *mut TfLiteRegistrationExternal,
    );
    #[doc = " Enables users to cancel in-flight invocations with\n `TfLiteInterpreterCancel`.\n\n By default it is disabled and calling to `TfLiteInterpreterCancel` will\n return kTfLiteError. See `TfLiteInterpreterCancel`.\n\n \\warning This is an experimental API and subject to change."]
    pub fn TfLiteInterpreterOptionsEnableCancellation(
        options: *mut TfLiteInterpreterOptions,
        enable: bool,
    ) -> TfLiteStatus;
    #[doc = " Returns a new interpreter using the provided model and options, or null on\n failure.\n\n * `model` must be a valid model instance. The caller retains ownership of\n   the object, and may destroy it (via TfLiteModelDelete) immediately after\n   creating the interpreter.  However, if the TfLiteModel was allocated with\n   TfLiteModelCreate, then the `model_data` buffer that was passed to\n   TfLiteModelCreate must outlive the lifetime of the TfLiteInterpreter\n   object that this function returns, and must not be modified during that\n   time; and if the TfLiteModel was allocated with TfLiteModelCreateFromFile,\n   then the contents of the model file must not be modified during the\n   lifetime of the TfLiteInterpreter object that this function returns.\n * `optional_options` may be null. The caller retains ownership of the\n   object, and can safely destroy it (via TfLiteInterpreterOptionsDelete)\n   immediately after creating the interpreter.\n\n \\note The client *must* explicitly allocate tensors before attempting to\n access input tensor data or invoke the interpreter."]
    pub fn TfLiteInterpreterCreate(
        model: *const TfLiteModel,
        optional_options: *const TfLiteInterpreterOptions,
    ) -> *mut TfLiteInterpreter;
    #[doc = " Destroys the interpreter."]
    pub fn TfLiteInterpreterDelete(interpreter: *mut TfLiteInterpreter);
    #[doc = " Returns the number of input tensors associated with the model."]
    pub fn TfLiteInterpreterGetInputTensorCount(interpreter: *const TfLiteInterpreter) -> i32;
    #[doc = " Returns a pointer to an array of input tensor indices.  The length of the\n array can be obtained via a call to `TfLiteInterpreterGetInputTensorCount`.\n\n Typically the input tensors associated with an `interpreter` would be set\n during the initialization of the `interpreter`, through a mechanism like the\n `InterpreterBuilder`, and remain unchanged throughout the lifetime of the\n interpreter.  However, there are some circumstances in which the pointer may\n not remain valid throughout the lifetime of the interpreter, because calls\n to `SetInputs` on the interpreter invalidate the returned pointer.\n\n The ownership of the array remains with the TFLite runtime."]
    pub fn TfLiteInterpreterInputTensorIndices(
        interpreter: *const TfLiteInterpreter,
    ) -> *const core::ffi::c_int;
    #[doc = " Returns the tensor associated with the input index.\n REQUIRES: 0 <= input_index < TfLiteInterpreterGetInputTensorCount(tensor)"]
    pub fn TfLiteInterpreterGetInputTensor(
        interpreter: *const TfLiteInterpreter,
        input_index: i32,
    ) -> *mut TfLiteTensor;
    #[doc = " Resizes the specified input tensor.\n\n \\note After a resize, the client *must* explicitly allocate tensors before\n attempting to access the resized tensor data or invoke the interpreter.\n\n REQUIRES: 0 <= input_index < TfLiteInterpreterGetInputTensorCount(tensor)\n\n This function makes a copy of the input dimensions, so the client can safely\n deallocate `input_dims` immediately after this function returns."]
    pub fn TfLiteInterpreterResizeInputTensor(
        interpreter: *mut TfLiteInterpreter,
        input_index: i32,
        input_dims: *const core::ffi::c_int,
        input_dims_size: i32,
    ) -> TfLiteStatus;
    #[doc = " Updates allocations for all tensors, resizing dependent tensors using the\n specified input tensor dimensionality.\n\n This is a relatively expensive operation, and need only be called after\n creating the graph and/or resizing any inputs."]
    pub fn TfLiteInterpreterAllocateTensors(interpreter: *mut TfLiteInterpreter) -> TfLiteStatus;
    #[doc = " Runs inference for the loaded graph.\n\n Before calling this function, the caller should first invoke\n TfLiteInterpreterAllocateTensors() and should also set the values for the\n input tensors.  After successfully calling this function, the values for the\n output tensors will be set.\n\n \\note It is possible that the interpreter is not in a ready state to\n evaluate (e.g., if AllocateTensors() hasn't been called, or if a\n ResizeInputTensor() has been performed without a subsequent call to\n AllocateTensors()).\n\n   If the (experimental!) delegate fallback option was enabled in the\n   interpreter options, then the interpreter will automatically fall back to\n   not using any delegates if execution with delegates fails. For details,\n   see TfLiteInterpreterOptionsSetEnableDelegateFallback in\n   c_api_experimental.h.\n\n Returns one of the following status codes:\n  - kTfLiteOk: Success. Output is valid.\n  - kTfLiteDelegateError: Execution with delegates failed, due to a problem\n    with the delegate(s). If fallback was not enabled, output is invalid.\n    If fallback was enabled, this return value indicates that fallback\n    succeeded, the output is valid, and all delegates previously applied to\n    the interpreter have been undone.\n  - kTfLiteApplicationError: Same as for kTfLiteDelegateError, except that\n    the problem was not with the delegate itself, but rather was\n    due to an incompatibility between the delegate(s) and the\n    interpreter or model.\n  - kTfLiteError: Unexpected/runtime failure. Output is invalid."]
    pub fn TfLiteInterpreterInvoke(interpreter: *mut TfLiteInterpreter) -> TfLiteStatus;
    #[doc = " Returns the number of output tensors associated with the model."]
    pub fn TfLiteInterpreterGetOutputTensorCount(interpreter: *const TfLiteInterpreter) -> i32;
    #[doc = " Returns a pointer to an array of output tensor indices.  The length of the\n array can be obtained via a call to `TfLiteInterpreterGetOutputTensorCount`.\n\n Typically the output tensors associated with an `interpreter` would be set\n during the initialization of the `interpreter`, through a mechanism like the\n `InterpreterBuilder`, and remain unchanged throughout the lifetime of the\n interpreter.  However, there are some circumstances in which the pointer may\n not remain valid throughout the lifetime of the interpreter, because calls\n to `SetOutputs` on the interpreter invalidate the returned pointer.\n\n The ownership of the array remains with the TFLite runtime."]
    pub fn TfLiteInterpreterOutputTensorIndices(
        interpreter: *const TfLiteInterpreter,
    ) -> *const core::ffi::c_int;
    #[doc = " Returns the tensor associated with the output index.\n REQUIRES: 0 <= output_index < TfLiteInterpreterGetOutputTensorCount(tensor)\n\n \\note The shape and underlying data buffer for output tensors may be not\n be available until after the output tensor has been both sized and\n allocated.\n In general, best practice is to interact with the output tensor *after*\n calling TfLiteInterpreterInvoke()."]
    pub fn TfLiteInterpreterGetOutputTensor(
        interpreter: *const TfLiteInterpreter,
        output_index: i32,
    ) -> *const TfLiteTensor;
    #[doc = " Returns modifiable access to the tensor that corresponds to the\n specified `index` and is associated with the provided `interpreter`.\n\n This requires the `index` to be between 0 and N - 1, where N is the\n number of tensors in the model.\n\n Typically the tensors associated with the `interpreter` would be set during\n the `interpreter` initialization, through a mechanism like the\n `InterpreterBuilder`, and remain unchanged throughout the lifetime of the\n interpreter.  However, there are some circumstances in which the pointer may\n not remain valid throughout the lifetime of the interpreter, because calls\n to `AddTensors` on the interpreter invalidate the returned pointer.\n\n Note the difference between this function and\n `TfLiteInterpreterGetInputTensor` (or `TfLiteInterpreterGetOutputTensor` for\n that matter): `TfLiteInterpreterGetTensor` takes an index into the array of\n all tensors associated with the `interpreter`'s model, whereas\n `TfLiteInterpreterGetInputTensor` takes an index into the array of input\n tensors.\n\n The ownership of the tensor remains with the TFLite runtime, meaning the\n caller should not deallocate the pointer."]
    pub fn TfLiteInterpreterGetTensor(
        interpreter: *const TfLiteInterpreter,
        index: core::ffi::c_int,
    ) -> *mut TfLiteTensor;
    #[doc = " Tries to cancel any in-flight invocation.\n\n \\note This only cancels `TfLiteInterpreterInvoke` calls that happen before\n calling this and it does not cancel subsequent invocations.\n \\note Calling this function will also cancel any in-flight invocations of\n SignatureRunners constructed from this interpreter.\n Non-blocking and thread safe.\n\n Returns kTfLiteError if cancellation is not enabled via\n `TfLiteInterpreterOptionsEnableCancellation`.\n\n \\warning This is an experimental API and subject to change."]
    pub fn TfLiteInterpreterCancel(interpreter: *const TfLiteInterpreter) -> TfLiteStatus;
    #[doc = " Returns the type of a tensor element."]
    pub fn TfLiteTensorType(tensor: *const TfLiteTensor) -> TfLiteType;
    #[doc = " Returns the number of dimensions that the tensor has.  Returns -1 in case\n the 'opaque_tensor' does not have its dimensions property set."]
    pub fn TfLiteTensorNumDims(tensor: *const TfLiteTensor) -> i32;
    #[doc = " Returns the length of the tensor in the \"dim_index\" dimension.\n REQUIRES: 0 <= dim_index < TFLiteTensorNumDims(tensor)"]
    pub fn TfLiteTensorDim(tensor: *const TfLiteTensor, dim_index: i32) -> i32;
    #[doc = " Returns the size of the underlying data in bytes."]
    pub fn TfLiteTensorByteSize(tensor: *const TfLiteTensor) -> usize;
    #[doc = " Returns a pointer to the underlying data buffer.\n\n \\note The result may be null if tensors have not yet been allocated, e.g.,\n if the Tensor has just been created or resized and `TfLiteAllocateTensors()`\n has yet to be called, or if the output tensor is dynamically sized and the\n interpreter hasn't been invoked."]
    pub fn TfLiteTensorData(tensor: *const TfLiteTensor) -> *mut core::ffi::c_void;
    #[doc = " Returns the (null-terminated) name of the tensor."]
    pub fn TfLiteTensorName(tensor: *const TfLiteTensor) -> *const core::ffi::c_char;
    #[doc = " Returns the parameters for asymmetric quantization. The quantization\n parameters are only valid when the tensor type is `kTfLiteUInt8` and the\n `scale != 0`. Quantized values can be converted back to float using:\n    real_value = scale * (quantized_value - zero_point);"]
    pub fn TfLiteTensorQuantizationParams(tensor: *const TfLiteTensor) -> TfLiteQuantizationParams;
    #[doc = " Copies from the provided input buffer into the tensor's buffer.\n REQUIRES: input_data_size == TfLiteTensorByteSize(tensor)"]
    pub fn TfLiteTensorCopyFromBuffer(
        tensor: *mut TfLiteTensor,
        input_data: *const core::ffi::c_void,
        input_data_size: usize,
    ) -> TfLiteStatus;
    #[doc = " Copies to the provided output buffer from the tensor's buffer.\n REQUIRES: output_data_size == TfLiteTensorByteSize(tensor)"]
    pub fn TfLiteTensorCopyToBuffer(
        output_tensor: *const TfLiteTensor,
        output_data: *mut core::ffi::c_void,
        output_data_size: usize,
    ) -> TfLiteStatus;
    #[doc = " Returns a new TfLiteRegistrationExternal instance.\n\n \\note The caller retains ownership and should ensure that\n the lifetime of the `TfLiteRegistrationExternal` must be at least as long as\n the lifetime of the `TfLiteInterpreter`.\n \\warning This is an experimental API and subject to change."]
    pub fn TfLiteRegistrationExternalCreate(
        builtin_code: TfLiteBuiltinOperator,
        custom_name: *const core::ffi::c_char,
        version: core::ffi::c_int,
    ) -> *mut TfLiteRegistrationExternal;
    #[doc = " Return the builtin op code of the provided external 'registration'.\n\n \\warning This is an experimental API and subject to change."]
    pub fn TfLiteRegistrationExternalGetBuiltInCode(
        registration: *const TfLiteRegistrationExternal,
    ) -> TfLiteBuiltinOperator;
    #[doc = " Returns the custom name of the provided 'registration'. The returned pointer\n will be non-null iff the op is a custom op.\n\n \\warning This is an experimental API and subject to change."]
    pub fn TfLiteRegistrationExternalGetCustomName(
        registration: *const TfLiteRegistrationExternal,
    ) -> *const core::ffi::c_char;
    #[doc = " Destroys the TfLiteRegistrationExternal instance.\n \\warning This is an experimental API and subject to change."]
    pub fn TfLiteRegistrationExternalDelete(registration: *mut TfLiteRegistrationExternal);
    #[doc = " Sets the initialization callback for the registration.\n\n The callback is called to initialize the op from serialized data.\n Please refer `init` of `TfLiteRegistration` for the detail.\n \\warning This is an experimental API and subject to change."]
    pub fn TfLiteRegistrationExternalSetInit(
        registration: *mut TfLiteRegistrationExternal,
        init: ::core::option::Option<
            unsafe extern "C" fn(
                context: *mut TfLiteOpaqueContext,
                buffer: *const core::ffi::c_char,
                length: usize,
            ) -> *mut core::ffi::c_void,
        >,
    );
    #[doc = " Sets the deallocation callback for the registration.\n\n This callback is called to deallocate the data returned by the init\n callback. The value passed in the `data` parameter is the value that was\n returned by the `init` callback.\n Please refer `free` of `TfLiteRegistration` for the detail.\n \\warning This is an experimental API and subject to change."]
    pub fn TfLiteRegistrationExternalSetFree(
        registration: *mut TfLiteRegistrationExternal,
        free: ::core::option::Option<
            unsafe extern "C" fn(context: *mut TfLiteOpaqueContext, data: *mut core::ffi::c_void),
        >,
    );
    #[doc = " Sets the preparation callback for the registration.\n\n The callback is called when the inputs of operator have been resized.\n Please refer `prepare` of `TfLiteRegistration` for the detail.\n \\warning This is an experimental API and subject to change."]
    pub fn TfLiteRegistrationExternalSetPrepare(
        registration: *mut TfLiteRegistrationExternal,
        prepare: ::core::option::Option<
            unsafe extern "C" fn(
                context: *mut TfLiteOpaqueContext,
                node: *mut TfLiteOpaqueNode,
            ) -> TfLiteStatus,
        >,
    );
    #[doc = " Sets the invocation callback for the registration.\n\n The callback is called when the operator is executed.\n Please refer `invoke` of `TfLiteRegistration` for the detail.\n \\warning This is an experimental API and subject to change."]
    pub fn TfLiteRegistrationExternalSetInvoke(
        registration: *mut TfLiteRegistrationExternal,
        invoke: ::core::option::Option<
            unsafe extern "C" fn(
                context: *mut TfLiteOpaqueContext,
                node: *mut TfLiteOpaqueNode,
            ) -> TfLiteStatus,
        >,
    );
}
